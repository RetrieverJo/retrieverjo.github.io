<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Hyunje Blog &#8211; Hyunje Blog</title>
<meta name="description" content="Blog for Hyunje">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">



<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Hyunje Blog">
<meta property="og:description" content="Blog for Hyunje">
<meta property="og:url" content="/page2/index.html">
<meta property="og:site_name" content="Hyunje Blog">





<link rel="canonical" href="/page2/">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Hyunje Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<!-- Webfonts -->
<link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">
<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
<link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/apple-touch-icon-144x144-precomposed.png">




<style type="text/css">body {background-image:url(/images/white.jpg);}</style>


</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="/images/avatar.jpg" alt="Hyunje Jo photo" class="author-photo">
					<h4>Hyunje Jo</h4>
					<p>Bigdata-technology based Machine Learning & Data Analysis</p>
				</li>
				<li><a href="/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:retriever89@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				
				<li>
					<a href="https://facebook.com/RetrieverJo"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/retrieverJo"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="/posts/">All Posts</a></li>
				<li><a href="/categories/">All Categories</a></li>
				<li><a href="/tags/">All Tags</a></li>
			</ul>
		</li>
		<!--
		
	    
	        
	    
	    <li><a href="/theme-setup/" >Theme Setup</a></li>
	  
	    
	        
	        
	    <li><a href="http://mademistakes.com" target="_blank">External Link</a></li>
	  
	  	-->
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  <div class="image-credit">Image source: <a href="">Hyunje Jo</a></div><!-- /.image-credit -->
  
    <div class="entry-image">
      <img src="/images/bg0.jpg" alt="Hyunje Blog">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Hyunje Blog</h1>
      <h2>Hyunje Blog</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="/data%20analysis/2015/07/27/advanced-analytics-with-spark-ch3-2/" title="Spark & 머신 러닝 - Recommending Music - 2/2"><img src="/images/bg3.jpg" alt="Spark & 머신 러닝 - Recommending Music - 2/2"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-07-27T17:09:00-04:00"><a href="/data%20analysis/2015/07/27/advanced-analytics-with-spark-ch3-2/">July 27, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About Hyunje Jo">Hyunje Jo</a></span></span>
      <!--
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~1 minute
      </span>
      -->
      <!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/data%20analysis/2015/07/27/advanced-analytics-with-spark-ch3-2/" rel="bookmark" title="Spark & 머신 러닝 - Recommending Music - 2/2" itemprop="url">Spark & 머신 러닝 - Recommending Music - 2/2</a></h1>
    
  </header>
  <div class="entry-content" style="overflow:hidden; height:500px;">
    <p><a href="http://hyunje.com/data%20analysis/2015/07/13/advanced-analytics-with-spark-ch3-1/">지난 포스트</a>에 이어 ALS를 이용한 추천 알고리즘의 성능을 평가하는 과정에 대한 글이다.</p>

<p>이 포스트는 <a href="http://shop.oreilly.com/product/0636920035091.do">Advanced Analytics with Spark</a>을 정리한 글이다.
<br>
<br></p>

<h2>Evaluating Recommendation Quality</h2>

<p>추천의 수행 결과를 평가하는 것으로 가장 정확한 방법은, 각 사용자가 추천 결과를 보고 그것에 대해 평가를 내리는 것이 가장 정확한 방식이다. 하지만 이러한 과정은 몇몇의 사용자를 샘플링 하여 진행한다고 하더라도 실제적으로 불가능에 가까운 방식이다. 때문에 사용자들이 들었던 아티스트들은 끌리는 아티스트들이고, 사용자들이 듣지 않은 아티스트들은 그렇지 않은 아티스트라고 가정하여 평가를 수행하는 것이 납득할만한 방법이다. 이러한 가정은 문제를 위한 가정이긴 하지만, 다른 데이터를 추가적으로 사용하지 않고 적용시킬 수 있다는 장점이 있다.</p>

<p>이 방법을 이용하여 추천 모델을 평가하기 위해서는 데이터를 분리하여 분리된 데이터는 ALS 모델을 생성하는 과정에서 제외시키는 과정이 필요하다. 그러면 이 분리된 데이터는 사용자들에 대한 좋은 추천 결과들을 가지고 있는 것으로 해석될 수 있다. 결과적으로 추천 시스템은 분리된 데이터를 제외하고 추천 모델을 생성시킨 후에 추천을 수행할 것이고, 추천이 이상적이라면 추천 시스템이 생성한 추천 결과의 상위권에 이 분리된 데이터들이 존재해야 할 것이다.</p>

<p>추천 결과를 분리한 아티스트의 리스트와 비교하여 0.0에서 1.0의 범위를 갖는 값(높을 수록 좋은 추천 결과를 나타냄)으로 수치화시킬 수 있다. (모든 아티스트의 쌍과 비교할 수 있지만, 그렇게 되면 너무 많은 쌍이 발생할 수 있기 때문에 일부 샘플된 쌍만 비교하는 것으로 한다.) 그리고 여기서 0.5는 무작위로 추천을 수행하였을 때의 기대값이라 한다.</p>

<p>이 방식은 <a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic">ROC Curve</a>와 직접적인 연관성을 갖는다. 앞서 얘기한 방식은 <a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_curve">AUC, Area Under the Curve</a>을 나타내는데, 이것은 무작위로 생성된 추천 결과에 비해 좋은 추천 결과들이 얼마만큼의 좋은 추천을 수행했는가 판단하는데에 이용된다.</p>

<p>AUC는 일반적인 Binary Classifier 와 같은 일반적인 Classifier 에서도 평가 방법으로 많이 이용된다. Spark의 MLlib에서는 BinaryClassificationMetrics에 이것이 구현되어있다. 이 글에서는 <strong>각 사용자별 AUC</strong>를 계산하고, 그것을 <strong>평균</strong>낼 것이다.</p>

<p><br>
<br></p>

<h2>Computing AUC</h2>

<p>이 절에서 수행되는 코드는 <a href="http://hyunje.com/data%20analysis/2015/07/13/advanced-analytics-with-spark-ch3-1/">지난 포스트</a>의 코드까지 수행된 것을 가정한다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">allData</span> <span class="k">=</span> <span class="n">rawUserArtistData</span><span class="o">.</span><span class="n">map</span><span class="o">{</span> <span class="n">line</span> <span class="k">=&gt;</span> 
    <span class="k">val</span> <span class="nc">Array</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">artistId</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toInt</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">finalArtistId</span> <span class="k">=</span> <span class="n">bArtistAlias</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">artistId</span><span class="o">,</span> <span class="n">artistId</span><span class="o">)</span>
    <span class="nc">Rating</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">finalArtistId</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span>
<span class="o">}.</span><span class="n">cache</span><span class="o">()</span>

<span class="k">val</span> <span class="nc">Array</span><span class="o">(</span><span class="n">trainData</span><span class="o">,</span> <span class="n">cvData</span><span class="o">)</span> <span class="k">=</span> <span class="n">allData</span><span class="o">.</span><span class="n">randomSplit</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="mf">0.9</span><span class="o">,</span> <span class="mf">0.1</span><span class="o">))</span>
<span class="n">trainData</span><span class="o">.</span><span class="n">cache</span><span class="o">()</span>
<span class="n">cvData</span><span class="o">.</span><span class="n">cache</span><span class="o">()</span>

<span class="k">val</span> <span class="n">allItemIDs</span> <span class="k">=</span> <span class="n">allData</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">product</span><span class="o">).</span><span class="n">distinct</span><span class="o">().</span><span class="n">collect</span><span class="o">()</span>
<span class="k">val</span> <span class="n">bAllItemIDs</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">broadcast</span><span class="o">(</span><span class="n">allItemIDs</span><span class="o">)</span>

<span class="k">val</span> <span class="n">model</span> <span class="k">=</span> <span class="nc">ALS</span><span class="o">.</span><span class="n">trainImplicit</span><span class="o">(</span><span class="n">trainData</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mf">0.01</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">)</span>
</code></pre></div>
<p>위 코드는 데이터셋을 9:1의 비율로 나누어 90%의 데이터를 트레이닝 데이터로, 나머지 10%의 데이터를 Cross-Validation 데이터로 사용하여 추천 모델을 훈련시키는 과정을 나타낸다.</p>

<p>그리고 다음 코드는, 생성된 추천 모델의 <code>predict</code> 함수를 이용하여 AUC를 계산하는 것에 대한 함수이다. 이 함수를 그대로 shell 에 입력하거나, 따로 파일에 작성하여 이전 포스트 에서 수행하였던 방식처럼 불러와도 된다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.spark.rdd.RDD</span>
<span class="k">import</span> <span class="nn">org.apache.spark.broadcast.Broadcast</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>
<span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="c1">// 각 사용자별로 AUC를 계산하고, 평균 AUC를 반환하는 함수.</span>
<span class="k">def</span> <span class="n">areaUnderCurve</span><span class="o">(</span>
      <span class="n">positiveData</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">Rating</span><span class="o">],</span>
      <span class="n">bAllItemIDs</span><span class="k">:</span> <span class="kt">Broadcast</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]],</span>
      <span class="n">predictFunction</span><span class="k">:</span> <span class="o">(</span><span class="kt">RDD</span><span class="o">[(</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">)]</span> <span class="o">=&gt;</span> <span class="nc">RDD</span><span class="o">[</span><span class="kt">Rating</span><span class="o">]))</span> <span class="k">=</span> <span class="o">{</span>

    <span class="c1">// Positive로 판단되는 결과들, 즉 전체 데이터에서 Cross-validation을 하기 위해 남겨둔</span>
    <span class="c1">// 10%의 데이터를 이용하여 Positive한 데이터로 저장한다.</span>
    <span class="k">val</span> <span class="n">positiveUserProducts</span> <span class="k">=</span> <span class="n">positiveData</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="n">user</span><span class="o">,</span> <span class="n">r</span><span class="o">.</span><span class="n">product</span><span class="o">))</span>
    <span class="c1">// Positive 데이터에서 (사용자, 아티스트ID)별로 각각의 쌍에 대한 예측치를 계산하고,</span>
    <span class="c1">// 그 결과를 사용자별로 그룹화한다.</span>
    <span class="k">val</span> <span class="n">positivePredictions</span> <span class="k">=</span> <span class="n">predictFunction</span><span class="o">(</span><span class="n">positiveUserProducts</span><span class="o">).</span><span class="n">groupBy</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">user</span><span class="o">)</span>

    <span class="c1">// 각 사용자에 대한 Negative 데이터(전체 데이터셋 - Positive 데이터)를 생성한다.</span>
    <span class="c1">// 전체 데이터 셋에서 Positive 데이터를 제외한 아이템 중 무작위로 선택한다.</span>
    <span class="k">val</span> <span class="n">negativeUserProducts</span> <span class="k">=</span> <span class="n">positiveUserProducts</span><span class="o">.</span><span class="n">groupByKey</span><span class="o">().</span><span class="n">mapPartitions</span> <span class="o">{</span>
      <span class="c1">// 각 파티션에 대해서 수행한다.</span>
      <span class="n">userIDAndPosItemIDs</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="c1">// 각 파티션 별로 난수 생성기를 초기화</span>
        <span class="k">val</span> <span class="n">random</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">()</span>
        <span class="k">val</span> <span class="n">allItemIDs</span> <span class="k">=</span> <span class="n">bAllItemIDs</span><span class="o">.</span><span class="n">value</span>

        <span class="n">userIDAndPosItemIDs</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">userID</span><span class="o">,</span> <span class="n">posItemIDs</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="k">val</span> <span class="n">posItemIDSet</span> <span class="k">=</span> <span class="n">posItemIDs</span><span class="o">.</span><span class="n">toSet</span>
          <span class="k">val</span> <span class="n">negative</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span>
          <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
          <span class="c1">// Positive 아이템의 갯수를 벗어나지 않도록하는 범위 내에서</span>
          <span class="c1">// 모든 아이템 중 무작위로 아이템을 선택하여</span>
          <span class="c1">// Positive 아이템이 아니라면 Negative 아이템으로 간주한다.</span>
          <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">allItemIDs</span><span class="o">.</span><span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">negative</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">posItemIDSet</span><span class="o">.</span><span class="n">size</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">val</span> <span class="n">itemID</span> <span class="k">=</span> <span class="n">allItemIDs</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">allItemIDs</span><span class="o">.</span><span class="n">size</span><span class="o">))</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">posItemIDSet</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">itemID</span><span class="o">))</span> <span class="o">{</span>
              <span class="n">negative</span> <span class="o">+=</span> <span class="n">itemID</span>
            <span class="o">}</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="o">}</span>
          <span class="c1">// (사용자 아이디, Negative 아이템 아이디)의 쌍을 반환한다.</span>
          <span class="n">negative</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">itemID</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">userID</span><span class="o">,</span> <span class="n">itemID</span><span class="o">))</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">t</span> <span class="k">=&gt;</span> <span class="n">t</span><span class="o">)</span>
    <span class="c1">// flatMap을 이용하여 묶여져 있는 셋을 하나의 큰 RDD로 쪼갠다.</span>

    <span class="c1">// Negative 아이템(아티스트)에 대한 예측치를 계산한다.</span>
    <span class="k">val</span> <span class="n">negativePredictions</span> <span class="k">=</span> <span class="n">predictFunction</span><span class="o">(</span><span class="n">negativeUserProducts</span><span class="o">).</span><span class="n">groupBy</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">user</span><span class="o">)</span>

    <span class="c1">// 각 사용자별로 Positive 아이템과 Negative 아이템을 Join 한다.</span>
    <span class="n">positivePredictions</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">negativePredictions</span><span class="o">).</span><span class="n">values</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">positiveRatings</span><span class="o">,</span> <span class="n">negativeRatings</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="c1">// AUC는 무작위로 선별된(처음에 10%를 무작위로 분리하였으므로) Positive 아이템의 Score가</span>
        <span class="c1">// 무작위로 선별된(negativeUserProducts 를 구할 때 무작위로 선택하였으므로) Negative 아이템의 Score보다</span>
        <span class="c1">// 높을 확률을 나타낸다. 이때, 모든 Postive 아이템과 Negative 아이템의 쌍을 비교하여 그 비율을 계산한다.</span>

        <span class="k">var</span> <span class="n">correct</span> <span class="k">=</span> <span class="mi">0L</span>
        <span class="k">var</span> <span class="n">total</span> <span class="k">=</span> <span class="mi">0L</span>
        <span class="c1">// 모든 Positive 아이템과 Negative 아이템의 쌍에 대해</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">positive</span> <span class="k">&lt;-</span> <span class="n">positiveRatings</span><span class="o">;</span> <span class="n">negative</span> <span class="k">&lt;-</span> <span class="n">negativeRatings</span><span class="o">)</span> <span class="o">{</span>
          <span class="c1">// Positive 아이템의 예측치가 Negative 아이템의 예측치보다 높다면 옳은 추천 결과</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">positive</span><span class="o">.</span><span class="n">rating</span> <span class="o">&gt;</span> <span class="n">negative</span><span class="o">.</span><span class="n">rating</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">correct</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="o">}</span>
          <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="o">}</span>
        <span class="c1">// 전체 쌍에서 옳은 추천 결과의 비율을 이용한 각 사용자별 AUC 계산</span>
        <span class="n">correct</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">/</span> <span class="n">total</span>
    <span class="o">}.</span><span class="n">mean</span><span class="o">()</span> <span class="c1">// 전체 사용자의 AUC 평균을 계산하고 리턴한다.</span>
  <span class="o">}</span>
</code></pre></div>
<p>위 함수를 이용하여 다음과 같이 AUC를 계산할 수 있다. 함수의 동작 과정에 대한 설명은 코드에 포함되어 있는 주석으로 대신한다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">auc</span> <span class="k">=</span> <span class="n">areaUnderCurve</span><span class="o">(</span><span class="n">cvData</span><span class="o">,</span> <span class="n">bAllItemIDs</span><span class="o">,</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="o">)</span>
<span class="o">...</span>
<span class="n">auc</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">0.9623184489901165</span>
</code></pre></div>
<p>수행 결과는 조금 다를 수 있겠지만 거의 0.96에 가까운 수치가 나올 것이다. 이 수치는 무작위로 추천을 수행했을 때의 기대값인 0.5 보다 많이 높은 값이며, 최대값인 1.0에 매우 가까운 수치이다. 따라서 괜찮은 추천을 수행해 주었다고 할 수 있다.</p>

<p>이 과정을 전체 데이터 셋을 90%의 트레이닝 데이터와 나머지 10% 데이터로 구분하는 것부터 다시 수행함으로써 좀 더 최적화된 평가 수치를 얻을 수 있다. 실제로 전체 데이터 셋을 \(k\)개의 서브셋으로 분리하고, \(k-1\)개의 서브셋을 트레이닝 데이터로, 나머지 한 개의 서브셋을 평가용으로 사용하여 \(k\)번 반복하는 방식이 존재한다. 이것이 일반적으로 불리는 <a href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)#k-fold_cross-validation">K-fold Cross-validation</a> 방식이다.</p>

<p>앞서 계산한 결과가 어느정도의 결과를 갖는지 간단한 벤치마크 값을 계산하여 비교해 볼 수도 있다. 모든 사용자에게 가장 많이 플레이 된 아티스트를 똑같이 추천해 주는 것이다. 이런 추천은 개인화된 추천이 아니지만 간단하고, 빠른 방법이다. 이 경우의 AUC를 계산하여 앞서 계산한 결과와 어느정도 차이가 있는지 확인해 볼 수 있다.</p>

<p>다음과 같이 함수 <code>predictMostListened</code>함수를 정의하여 사용한다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.spark.SparkContext</span>

<span class="k">def</span> <span class="n">predictMostListened</span><span class="o">(</span><span class="n">sc</span><span class="k">:</span> <span class="kt">SparkContext</span><span class="o">,</span> <span class="n">train</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">Rating</span><span class="o">])(</span><span class="n">allData</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">bListenCount</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">broadcast</span><span class="o">(</span>
        <span class="n">train</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="n">product</span><span class="o">,</span> <span class="n">r</span><span class="o">.</span><span class="n">rating</span><span class="o">)).</span><span class="n">reduceByKey</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">).</span><span class="n">collectAsMap</span><span class="o">()</span>
    <span class="o">)</span>
    <span class="n">allData</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">product</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nc">Rating</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">product</span><span class="o">,</span> <span class="n">bListenCount</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">product</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">auc</span> <span class="k">=</span> <span class="n">areaUnderCurve</span><span class="o">(</span><span class="n">cvData</span><span class="o">,</span> <span class="n">bAllItemIDs</span><span class="o">,</span> <span class="n">predictMostListened</span><span class="o">(</span><span class="n">sc</span><span class="o">,</span> <span class="n">trainData</span><span class="o">))</span>
</code></pre></div>
<p>이 결과는 0.93 정도가 나온다. 앞서 우리가 추천 모델을 이용하여 수행한 추천의 결과가 더 높은 것을 알 수 있다. 하지만 좀 더 결과를 좋게 만들 수 없을까?
<br>
<br></p>

<h2>Hyperparameter Selection</h2>

<p>한 가지 간단한 방법은 추천 모델 형성에 사용된 몇 개의 <a href="https://en.wikipedia.org/wiki/Hyperparameter">Hyperparameter</a>를 조절해보는 것이다. 지금까지의 추천 모델 형성 과정에서는 이 값에 대해 언급이 없었지만, 사용되었던 파라미터와 그 기본값은 다음과 같다.</p>

<h4>rank = 10</h4>

<p><em>rank</em> 파라미터는 <em>user-feature</em> 행렬과 <em>product-feature</em> 행렬을 구성할 때 column \(k\)의 크기를 의미한다.</p>

<h4>iterations = 5</h4>

<p><em>iterations</em>는 Matrix Factorization 과정을 몇번 반복할 것인가에 대한 것이다. 횟수가 많아질 수록 추천의 성능은 좋아지지만, 수행 시간이 늘어난다.</p>

<h4>lambda = 0.01</h4>

<p><em>Overfitting</em>을 막아주는 파라미터이다. 값이 높을수록 Overfitting 을 막아주지만, 너무 높다면 추천의 정확도를 저하시킨다.</p>

<h4>alpha = 1.0</h4>

<p><em>Alpha</em>는 Implicit Feedback 방식에서 사용되는 파라미터로, user-product의 baseline confidence(값이 존재하는 데이터와 그렇지 않은 데이터 중 어떤것에 초점을 둘 것인지)를 조절하는 파라미터이다.</p>

<p>이 파라미터들을 조절하여 추천 모델의 성능을 증가시킬 수 있다. 파라미터를 조절하여 최적의 값을 찾는 방식에는 다양한 방법이 있지만, 여기선 간단하게만 변화를 주어 테스트를 할 것이다. 다음 코드와 같이 각 <em>rank</em>, <em>lambda</em>, <em>alpha</em> 에 두 개의 값으로 변화를 주어 그 결과로 계산되는 AUC를 비교할 것이다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">evaluations</span> <span class="k">=</span>
    <span class="k">for</span><span class="o">(</span><span class="n">rank</span>    <span class="k">&lt;-</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">50</span><span class="o">);</span>
        <span class="n">lambda</span>  <span class="k">&lt;-</span> <span class="nc">Array</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">0.0001</span><span class="o">);</span>
        <span class="n">alpha</span>   <span class="k">&lt;-</span> <span class="nc">Array</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">40.0</span><span class="o">))</span>
        <span class="k">yield</span> <span class="o">{</span>
         <span class="k">val</span> <span class="n">model</span> <span class="k">=</span> <span class="nc">ALS</span><span class="o">.</span><span class="n">trainImplicit</span><span class="o">(</span><span class="n">trainData</span><span class="o">,</span> <span class="n">rank</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="n">lambda</span><span class="o">,</span> <span class="n">alpha</span><span class="o">)</span>
         <span class="k">val</span> <span class="n">auc</span> <span class="k">=</span> <span class="n">areaUnderCurve</span><span class="o">(</span><span class="n">cvData</span><span class="o">,</span> <span class="n">bAllItemIDs</span><span class="o">,</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="o">)</span>
         <span class="o">((</span><span class="n">rank</span><span class="o">,</span> <span class="n">lambda</span><span class="o">,</span> <span class="n">alpha</span><span class="o">),</span> <span class="n">auc</span><span class="o">)</span>
    <span class="o">}</span>

<span class="n">evaluations</span><span class="o">.</span><span class="n">sortBy</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">_2</span><span class="o">).</span><span class="n">reverse</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div>
<p>수행 결과는 다음과 같다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="o">((</span><span class="mi">10</span><span class="o">,</span><span class="mf">1.0</span><span class="o">,</span><span class="mf">40.0</span><span class="o">),</span><span class="mf">0.9775933769125035</span><span class="o">)</span>
<span class="o">((</span><span class="mi">50</span><span class="o">,</span><span class="mf">1.0</span><span class="o">,</span><span class="mf">40.0</span><span class="o">),</span><span class="mf">0.9775096131405069</span><span class="o">)</span>
<span class="o">((</span><span class="mi">10</span><span class="o">,</span><span class="mf">1.0E-4</span><span class="o">,</span><span class="mf">40.0</span><span class="o">),</span><span class="mf">0.9767512207167729</span><span class="o">)</span>
<span class="o">((</span><span class="mi">50</span><span class="o">,</span><span class="mf">1.0E-4</span><span class="o">,</span><span class="mf">40.0</span><span class="o">),</span><span class="mf">0.9761886422104153</span><span class="o">)</span>
<span class="o">((</span><span class="mi">10</span><span class="o">,</span><span class="mf">1.0</span><span class="o">,</span><span class="mf">1.0</span><span class="o">),</span><span class="mf">0.9691674538720272</span><span class="o">)</span>
<span class="o">((</span><span class="mi">50</span><span class="o">,</span><span class="mf">1.0</span><span class="o">,</span><span class="mf">1.0</span><span class="o">),</span><span class="mf">0.9670028532287775</span><span class="o">)</span>
<span class="o">((</span><span class="mi">10</span><span class="o">,</span><span class="mf">1.0E-4</span><span class="o">,</span><span class="mf">1.0</span><span class="o">),</span><span class="mf">0.9648010615992904</span><span class="o">)</span>
<span class="o">((</span><span class="mi">50</span><span class="o">,</span><span class="mf">1.0E-4</span><span class="o">,</span><span class="mf">1.0</span><span class="o">),</span><span class="mf">0.9545102924987607</span><span class="o">)</span>
</code></pre></div>
<p>위 결과로 보아 rank는 10, lambda는 1.0, alpha를 40으로 하였을 때가 기본 설정으로 하였을 때보다 추천 성능이 좋음을 알 수 있다. 이런 방식으로 추천 모델을 최적화할 수 있다.</p>

<p>여기서 각 파라미터가 추천 결과에 어떤 영향을 미치는지 분석할 수 있다. <em>Alpha</em> 파라미터는 1일 때보다 40일때 추천의 성능이 증가되었다. 흥미로운 점은 이 40이라는 값이 지난 포스트에서 언급한 논문이 제안한 기본값이라는 것이다. 그리고 낮은 값인 1 보다 큰 값인 40일 때 성능이 좋은 것으로 보아 사용자가 특정 아티스트를 들었다는 정보가 듣지 않았다는 정보보다 추천 모델을 형성하는데에 있어 더욱 효과적이라는 것을 나타낸다.</p>

<p><em>lambda</em>는 매우 적은 차이를 이끌어낸다. 하지만 높은 Lambda를 사용하였을 때 추천 성능이 더욱 좋은 것으로 보아 Overfitting을 효과적으로 방지하였음을 알 수 있다. Overfitting에 대해서는 다음 장에서 자세하게 살펴 볼 것이다.</p>

<p>column의 크기 \(k\)는 rank 파라미터의 값으로 보아 크게 중요하지 않음을 알 수 있다. 오히려 값이 50으로 클 때가 성능이 더 좋지 않았다. 따라서 너무 큰 \(k\)를 설정하게 되면 오히려 추천 성능이 감소함을 유추할 수 있다.</p>

<p>파라미터를 설정할 때 모든 파라미터에 대해 완벽하게 이해하고 있을 필요까지는 없다. 하지만 적어도 파라미터들이 어느 범위의 값을 갖는지 정도를 안다면, 여러 모델을 최적화하는데 많은 도움이 된다.</p>

  </div><!-- /.entry-content -->
  
  <center><div><a href="/data%20analysis/2015/07/27/advanced-analytics-with-spark-ch3-2/" class="btn">Read More...</a></div></center>
  
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="/data%20analysis/2015/07/13/advanced-analytics-with-spark-ch3-1/" title="Spark & 머신 러닝 - Recommending Music - 1/2"><img src="/images/bg2.jpg" alt="Spark & 머신 러닝 - Recommending Music - 1/2"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-07-13T19:09:00-04:00"><a href="/data%20analysis/2015/07/13/advanced-analytics-with-spark-ch3-1/">July 13, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About Hyunje Jo">Hyunje Jo</a></span></span>
      <!--
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~1 minute
      </span>
      -->
      <!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/data%20analysis/2015/07/13/advanced-analytics-with-spark-ch3-1/" rel="bookmark" title="Spark & 머신 러닝 - Recommending Music - 1/2" itemprop="url">Spark & 머신 러닝 - Recommending Music - 1/2</a></h1>
    
  </header>
  <div class="entry-content" style="overflow:hidden; height:500px;">
    <p>이 글에서는 Spark를 이용하여 추천을 수행하는 과정에 대해 설명한다. <a href="http://www-etud.iro.umontreal.ca/%7Ebergstrj/audioscrobbler_data.html">Audioscrobbler Dataset</a> 를 이용하여 사용자가 좋아할 만한 음악을 추천해 주는 작업을 할 것이다.</p>

<p>이 포스트는 <a href="http://shop.oreilly.com/product/0636920035091.do">Advanced Analytics with Spark</a>을 정리한 글이다.</p>

<p>Chapter 3를 두 개의 글로 나누었다. 첫 번째 글은 추천을 수행하고, 간단히 추천 수행 결과를 확인해 보는 정도로 마무리 하고, 두 번째 글은 생성한 추천 모델이 얼마나 효과적으로 추천을 수행해주는지 분석하는 과정이다.</p>

<p><br>
<br></p>

<h2>Introduction</h2>

<p>추천 엔진은 사람들이 가장 쉽게 접할 수 있는 머신 러닝의 한 예라고 할 수 있다. Amazon, Youtube과 같은 사이트는 물론 대부분의 서비스는 자체적으로 추천 기능을 제공한다. 추천 시스템의 결과물은 현재 시스템을 사용하고 있는 사람이 좋아할만한 아이템이기 때문에, 다른 머신 러닝 알고리즘에 비해 좀 더 직관적으로 이해할 수 있다. 그만큼 추천 시스템은 많은 사람들에게 이미 널리 알려져 있고, 익숙한 머신 러닝 알고리즘이다.</p>

<p>이 챕터에서는 Spark에 정의되어 있는 핵심 머신 러닝 알고리즘 중 추천 시스템과 연관이 있는 것들에 대해 알아볼 것이고, 그것을 이용해 사용자에게 음악을 추천 해 줄 것이다. 이러한 과정들은 Spark와 MLlib의 실제 예시가 될것이며, 이어지는 다른 챕터들에서 사용하게 될 머신 러닝과 관련된 아이디어들에도 도움을 주게 될 것이다.</p>

<p><br>
<br></p>

<h2>Data Set</h2>

<p>이 챕터에서 수행할 예시 데이터는 <a href="http://www-etud.iro.umontreal.ca/%7Ebergstrj/audioscrobbler_data.html">Audtioscrobbler에서 제공하는 데이터셋</a>이다. Audioscrobbler 는 Last.fm 에서 처음으로 활용한 음악 추천 시스템이다. Audioscrobbler는 사용자들이 듣는 음악 정보를 자동으로 서버로 전송하여 기록하는 API 를 제공하였는데, 이러한 API의 사용은 많은 사용자의 정보를 기록하는 것으로 이어졌고, Last.fm 에서는 이 정보를 강력한 음악 추천 엔진을 구성하는데 사용하였다.</p>

<p>그 당시의 대부분의 추천 엔진에 대한 연구는 평가기반(사용자 x가 아이템 a에 평점 5를 남겼다)의 데이터에 대한 것들이었다. 하지만 흥미롭게도 Audioscrobbler 데이터는 사용자들이 어떠한 음악을 플레이했다에 대한 정보(사용자 x는 음악 a를 플레이했다.)밖에 제공되지 않는다. 이러한 데이터는 기존 데이터에 비해 난이도가 있는데, 그 이유는 사용자가 음악을 재생했다는 정보가 그 음악을 좋아한다고는 볼 수 없기 때문이다. 이러한 형태의 데이터 셋을 <strong>Implicit Feedback Dataset</strong>이라 한다.</p>

<p>위 링크에서 데이터셋을 다운로드 받아 압축을 해제하면 몇 개의 파일이 나온다. 그 중 가장 핵심이 되는 데이터 파일은 <code>user_artist_data.txt</code> 파일이다. 이 파일은 141,000명의 사용자와 160만명의 아티스트에 대한 정보가 들어있으며 사용자의 아티스트에 대한 플레이 정보는 약 2400만 정도의 기록이 저장되어있다. <code>artist_data.txt</code>파일은 모든 아티스트에 대한 정보가 들어있지만, 이 데이터 안에는 같은 아티스트를 가리키지만 서로 다른 이름으로 저장되어 있는 경우가 있다. 때문에 이를 위해 같은 아티스트를 가리키고 있는 ID의 Map인 <code>artist_alias.txt</code> 파일이 존재한다.</p>

<p><br>
<br></p>

<h2>The Alternating Least Squares Recommender Algorithm</h2>

<p>추천을 수행하기에 앞서, 설명한 데이터 셋의 형태에 맞는 추천 알고리즘을 선택해야 한다. 우리가 가지고 있는 데이터 셋은 Implicit feedback 형태이며, 사용자에 대한 정보(성별, 나이 등)라던가 아티스트에 대한 정보 역시 존재하지 않는다. 따라서 활용할 수 있는 정보는 <strong>어떠한 사용자가 어떤 아티스트의 노래를 들었다</strong> 라는 정보 뿐이고, 이러한 기록만 이용해서 추천을 수행해야 한다.</p>

<p>이러한 조건에 알맞는 추천 알고리즘은 <a href="https://en.wikipedia.org/wiki/Collaborative_filtering">Collaborative Filtering, CF</a><a href="https://ko.wikipedia.org/wiki/%ED%98%91%EC%97%85_%ED%95%84%ED%84%B0%EB%A7%81">(협업 필터링)</a>이다. CF는 아이템이나 사용자의 속성을 사용하지 않고 단순히 둘 사이의 관계정보(이 데이터 셋에서는 음악 플레이 여부)만 이용하여 추천을 수행하는 알고리즘이다.</p>

<p>CF에는 여러 알고리즘들이 존재하는데, 여기선 Matrix Factorization 모델을 이용한 추천 알고리즘을 이용하여 추천을 수행한다. Matrix Factorization 계열의 추천 알고리즘은 \( i \times j\) 크기의 행렬을 생성하고, 사용자 \(i\)가 아티스트 \(j\)의 음악을 플레이 했다는 정보를 행렬의 데이터로 이용한다. 이 행렬을 \(A\)라 할때, 전체 데이터에 비해서 사용자-아티스트의 조합이 매우 적기 때문에 행렬 \(A\)의 데이터는 듬성듬성 존재한다(Sparse 하다고 한다).</p>

<p>Matrix Factorization 방식에서는 이 행렬 \(A\)를 두 개의 작은 행렬 \(X\)와 \(Y\)로 쪼갠다. 이 때 각 행렬의 크기는 \(i \times k\), \(j \times k\)로, 원래 행렬의 행과 열의 크기가 매우 크기 때문에 두 행렬의 행 역시 매우 크다. 그리고 \(k\)는 Latent factor로써, 사용자와 아티스트 사이의 연관을 표현하는데에 이용된다.</p>

<p><img src="https://dl.dropboxusercontent.com/u/97648427/blog-img/ch3-1.png" alt="Matrix Factorization"></p>

<p>위 그림 3-1[1]과 같이 행렬 \(X, Y\)를 계산한 후에, 사용자 \(i\)의 아티스트 \(j\)에 대한 평점을 계산하기 위해서는 행렬 \(X\)의 \(i\)번째 행과, 행렬 \(Y^T\)의 \(j\)번째 열을 곱하여 계산한다.</p>

<p>이러한 방법을 기반으로 한 추천 알고리즘이 많이 존재 하는데, 이 챕터에서 사용되는 알고리즘은 Alternating Least Squares 알고리즘이다. 이 알고리즘은 Netflix Prize 에서 우승한 논문인 &quot;Collaborative Filtering for the Implicit Feedback Datasets&quot;과, &quot;Large-scale Parallel Collaborative Filtering for the Netflix Prize&quot;에서 주로 사용된 방식이다. 또한 Spark의 MLlib 에는 이 두 논문의 구현체가 구현되어 있다. 이 것을 이용해 이번 챕터를 진행 할 것이다.</p>

<p><br>
<br></p>

<h2>Preparing the Data</h2>

<p>다운로드 받은 <a href="http://www-etud.iro.umontreal.ca/%7Ebergstrj/audioscrobbler_data.html">Audtioscrobbler에서 제공하는 데이터셋</a>을 압축 해제하고, HDFS에 업로드한다. 다음과 같이 <code>/audio</code> 경로에 업로드하는것을 가정한다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">-rw-r--r--   1 hyunje supergroup    2932731 2015-07-12 04:19 /audio/artist_alias.txt
-rw-r--r--   1 hyunje supergroup   55963575 2015-07-12 04:19 /audio/artist_data.txt
-rw-r--r--   1 hyunje supergroup  426761761 2015-07-12 04:19 /audio/user_artist_data.txt
</code></pre></div>
<p>또한, 데이터의 크기가 크고, 계산량이 많기 때문에 Spark Shell 을 수행시킬 때 다음과 같이 드라이버의 메모리 용량을 <strong>6GB</strong>이상을 확보시켜야 한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">spark-shell --driver-memory 6g --master <span class="nb">local</span><span class="o">[</span>2<span class="o">]</span>
</code></pre></div>
<p>Spark의 MLlib 에 한 가지 제한이 있는데, 사용자와 아이템 아이디의 크기가 <code>Integer.MAX_VALUE</code> 보다 크면 안된다는 것이다. 즉 <code>2147483647</code>을 초과할 수 없다. 이를 다음과 같이 확인해 볼 수 있다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">rawUserArtistData</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="s">&quot;/audio/user_artist_data.txt&quot;</span><span class="o">)</span>
<span class="n">rawUserArtistData</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">)(</span><span class="mi">0</span><span class="o">).</span><span class="n">toDouble</span><span class="o">).</span><span class="n">stats</span><span class="o">()</span>
<span class="n">rawUserArtistData</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">)(</span><span class="mi">1</span><span class="o">).</span><span class="n">toDouble</span><span class="o">).</span><span class="n">stats</span><span class="o">()</span>
</code></pre></div>
<p>위 명령어의 수행 결과는 다음과 같으며, 이는 데이터를 다른 변환 없이 그대로 사용해도 무방함을 나타낸다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">org</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">StatCounter</span> <span class="k">=</span> <span class="o">(</span><span class="n">count</span><span class="k">:</span> <span class="err">24296858</span><span class="o">,</span> <span class="n">mean</span><span class="k">:</span> <span class="err">1947573</span><span class="kt">.</span><span class="err">265353</span><span class="o">,</span> <span class="n">stdev</span><span class="k">:</span> <span class="err">496000</span><span class="kt">.</span><span class="err">544975</span><span class="o">,</span> <span class="n">max</span><span class="k">:</span> <span class="err">2443548</span><span class="kt">.</span><span class="err">000000</span><span class="o">,</span> <span class="n">min</span><span class="k">:</span> <span class="err">90</span><span class="kt">.</span><span class="err">000000</span><span class="o">)</span>
<span class="n">org</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">StatCounter</span> <span class="k">=</span> <span class="o">(</span><span class="n">count</span><span class="k">:</span> <span class="err">24296858</span><span class="o">,</span> <span class="n">mean</span><span class="k">:</span> <span class="err">1718704</span><span class="kt">.</span><span class="err">093757</span><span class="o">,</span> <span class="n">stdev</span><span class="k">:</span> <span class="err">2539389</span><span class="kt">.</span><span class="err">040171</span><span class="o">,</span> <span class="n">max</span><span class="k">:</span> <span class="err">10794401</span><span class="kt">.</span><span class="err">000000</span><span class="o">,</span> <span class="n">min</span><span class="k">:</span> <span class="err">1</span><span class="kt">.</span><span class="err">000000</span><span class="o">)</span>
</code></pre></div>
<p>그리고 추천을 수행하기 위해 아티스트의 데이터를 읽어 이를 기억해야 할 필요가 있다. 다음과 코드를 이용해 아티스트 데이터를 불러올 수 있다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">rawArtistData</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="s">&quot;/audio/artist_data.txt&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">artistById</span> <span class="k">=</span> <span class="n">rawArtistData</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span> <span class="n">line</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">span</span><span class="o">(</span><span class="k">_</span> <span class="o">!=</span> <span class="sc">&#39;\t&#39;</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">None</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Some</span><span class="o">((</span><span class="n">id</span><span class="o">.</span><span class="n">toInt</span><span class="o">,</span> <span class="n">name</span><span class="o">.</span><span class="n">trim</span><span class="o">))</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
            <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">NumberFormatException</span> <span class="o">=&gt;</span> <span class="nc">None</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">})</span>
</code></pre></div>
<p>또한, 앞서 설명하였듯이 각 아티스트가 오타 등의 이유로 다른 텍스트로 표현될 수 있기 때문에 이를 하나로 통합시켜야 한다. <code>artist_alias.txt</code> 파일의 각 행은 두 개의 열 <code>badID \t good ID</code>로 이루어져 있으며, 해당 파일을 읽어 드라이버 에서 Map 형태로 기억하고 있는다. 이 작업은 다음 코드를 수행함으로써 이뤄진다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">rawArtistAlias</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="s">&quot;/audio/artist_alias.txt&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">artistAlias</span> <span class="k">=</span> <span class="n">rawArtistAlias</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span> <span class="n">line</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">tokens</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="sc">&#39;\t&#39;</span><span class="o">)</span>
    <span class="k">if</span><span class="o">(</span><span class="n">tokens</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">None</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="nc">Some</span><span class="o">((</span><span class="n">tokens</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toInt</span><span class="o">,</span> <span class="n">tokens</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">toInt</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}).</span><span class="n">collectAsMap</span><span class="o">()</span>
</code></pre></div>
<p><code>artistAlias.get(6803336)</code>의 결과는 아이디 <strong>1000010</strong>이기 때문에, 다음과 같은 예시를 통해 정상적으로 데이터가 불러와졌는지 확인할 수 있다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">artistById</span><span class="o">.</span><span class="n">lookup</span><span class="o">(</span><span class="mi">6803336</span><span class="o">)</span>
<span class="n">artistById</span><span class="o">.</span><span class="n">lookup</span><span class="o">(</span><span class="mi">1000010</span><span class="o">)</span>
</code></pre></div>
<p>위 코드의 수행 결과는 각각 <code>Aerosmith (unplugged)</code>와 <code>Aerosmith</code>를 나타내며, 이는 정상적인 결과를 의미한다.</p>

<h2>Building a First Model</h2>

<p>Spark 의 MLlib에 구현되어 있는 ALS를 사용하기 위해선 두 가지의 변환 과정이 필요하다. 첫번째는 기존에 구한 아티스트의 ID를 앞서 생성한 Map 을 이용하여 같은 ID끼리 묶어야 하며, 데이터를 MLlib의 ALS에서 사용하는 입력 형태인 <strong>Rating</strong> 객체로 변환해야 한다. <strong>Rating</strong>객체는 <code>사용자ID-ProductID-Value</code>형태를 갖는 객체인데, 이름은 Rating 이지만 Implicit 형태의 데이터에서도 사용 가능하다. 이 챕터에서는 Value를 ProductID 를 아티스트의 ID, Value를 사용자가 해당 아티스트의 노래를 재생한 횟수로 사용할 것이다. 다음과 같은 코드를 이용하여 추천을 수행하기 위한 데이터를 준비한다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.spark.mllib.recommendation._</span>

<span class="k">val</span> <span class="n">bArtistAlias</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">broadcast</span><span class="o">(</span><span class="n">artistAlias</span><span class="o">)</span>
<span class="k">val</span> <span class="n">trainData</span> <span class="k">=</span> <span class="n">rawUserArtistData</span><span class="o">.</span><span class="n">map</span><span class="o">(</span> <span class="n">line</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nc">Array</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">artistId</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toInt</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">finalArtistId</span> <span class="k">=</span> <span class="n">bArtistAlias</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">artistId</span><span class="o">,</span> <span class="n">artistId</span><span class="o">)</span>
    <span class="nc">Rating</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">finalArtistId</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span>
<span class="o">}).</span><span class="n">cache</span><span class="o">()</span>
</code></pre></div>
<p>위 코드에서 중요한 부분은 기존에 생성하였던 <code>artistAlias</code> Map 을 <strong>broadcast</strong>하는 과정이다. Broadcast를 하지 않는다면 artistAlias 를 Spark가 생성하는 모든 Task 마다 복사하여 사용하게 된다. 하지만 이러한 작업은 큰 비용을 소비한다. 각각의 과정은 최소 몇 메가 바이트 에서 몇십 메가 바이트(크기에 따라 다르며, 이 예시에서의 크기임)를 소비하기 때문에, JVM에서 생성하는 모든 Task 에 이 데이터를 복사한다는 것은 매우 비효율적이다.</p>

<p>따라서 생성한 Map을 Broadcasting 함으로써 Spark Cluster의 각 Executer 가 단 하나의 Map만 유지할 수 있도록 한다. 때문에 Cluster에서 여러 Executer 가 수많은 Task 를 생성할 때 메모리를 효율적으로 관리할 수 있도록 해준다.</p>

<p>그리고 지금까지 계산한 결과를 <strong>cache()</strong>를 통해 메모리에 임시 저장함으로써, <code>trainData</code> 변수를 접근할 때마다 map 을 다시 수행하는 것을 막는다.</p>

<p>생성한 변수들을 이용해 다음과 같이 추천 모델을 생성할 수 있다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">model</span> <span class="k">=</span> <span class="nc">ALS</span><span class="o">.</span><span class="n">trainImplicit</span><span class="o">(</span><span class="n">trainData</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mf">0.01</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">)</span>
</code></pre></div>
<p>위 과정은 앞에서 설명한 MatrixFactoriation 방식을 이용해 추천 모델을 생성하는 과정이다. 이때 클러스터의 상태에 따라 수행시간은 몇 분 정도 수행될 수 있다. 그리고 다음 코드를 수행함으로써 내부 Feature 들이 정상적으로 계산되었는지 확인한다(정확한 값인지는 모르지만).</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">model</span><span class="o">.</span><span class="n">userFeatures</span><span class="o">.</span><span class="n">mapValues</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;, &quot;</span><span class="o">)).</span><span class="n">first</span><span class="o">()</span>
<span class="n">model</span><span class="o">.</span><span class="n">productFeatures</span><span class="o">.</span><span class="n">mapValues</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;, &quot;</span><span class="o">)).</span><span class="n">first</span><span class="o">()</span>

<span class="o">...</span>

<span class="o">(</span><span class="nc">Int</span><span class="o">,</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="mi">90</span><span class="o">,-</span><span class="mf">0.8930547833442688</span><span class="o">,</span> <span class="o">-</span><span class="mf">0.7431690096855164</span><span class="o">,</span> <span class="o">-</span><span class="mf">0.6351532936096191</span><span class="o">,</span> <span class="o">-</span><span class="mf">0.28394362330436707</span><span class="o">,</span> <span class="mf">0.14852239191532135</span><span class="o">,</span> <span class="o">-</span><span class="mf">0.37798216938972473</span><span class="o">,</span> <span class="o">-</span><span class="mf">0.923484742641449</span><span class="o">,</span> <span class="o">-</span><span class="mf">0.12640361487865448</span><span class="o">,</span> <span class="mf">0.5575262308120728</span><span class="o">,</span> <span class="o">-</span><span class="mf">0.35868826508522034</span><span class="o">)</span>
<span class="o">(</span><span class="nc">Int</span><span class="o">,</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="mi">2</span><span class="o">,-</span><span class="mf">0.08458994328975677</span><span class="o">,</span> <span class="mf">0.027468876913189888</span><span class="o">,</span> <span class="o">-</span><span class="mf">0.16536176204681396</span><span class="o">,</span> <span class="mf">0.08694511651992798</span><span class="o">,</span> <span class="mf">0.019154658541083336</span><span class="o">,</span> <span class="o">-</span><span class="mf">0.12874850630760193</span><span class="o">,</span> <span class="o">-</span><span class="mf">0.04696394130587578</span><span class="o">,</span> <span class="o">-</span><span class="mf">0.0629991888999939</span><span class="o">,</span> <span class="mf">0.15156564116477966</span><span class="o">,</span> <span class="mf">0.0011008649598807096</span><span class="o">)</span>
</code></pre></div>
<p>알고리즘이 랜덤성을 갖고 있기 때문에 수행 결과는 위와 다를 수 있다.</p>

<p><br>
<br></p>

<h2>Spot Checking Recommendations</h2>

<p>이제 실제로 사용자들에게 추천을 잘 수행해 주었는가를 확인해 봐야 한다. 2093760 사용자에 대해 과연 추천을 잘 수행했는지 확인해 볼 것이다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">rawArtistsForUser</span> <span class="k">=</span> <span class="n">rawUserArtistData</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">)).</span><span class="n">filter</span><span class="o">({</span>
    <span class="k">case</span> <span class="nc">Array</span><span class="o">(</span><span class="n">user</span><span class="o">,</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">user</span><span class="o">.</span><span class="n">toInt</span> <span class="o">==</span> <span class="mi">2093760</span>
<span class="o">})</span>

<span class="k">val</span> <span class="n">existingProducts</span> <span class="k">=</span> <span class="n">rawArtistsForUser</span><span class="o">.</span><span class="n">map</span><span class="o">({</span>
    <span class="k">case</span> <span class="nc">Array</span><span class="o">(</span><span class="k">_</span><span class="o">,</span><span class="n">artist</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">artist</span><span class="o">.</span><span class="n">toInt</span>
<span class="o">}).</span><span class="n">collect</span><span class="o">.</span><span class="n">toSet</span>

<span class="n">artistById</span><span class="o">.</span><span class="n">filter</span><span class="o">({</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">existingProducts</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
<span class="o">}).</span><span class="n">values</span><span class="o">.</span><span class="n">collect</span><span class="o">().</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div>
<p>위 코드의 수행 결과는 다음과 같은 결과를 보이는데,</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">David Gray
Blackalicious
Jurassic 5
The Saw Doctors
Xzibit
</code></pre></div>
<p>이 결과는 2093760 사용자가 플레이한 아티스트의 목록이다. 플레이했던 아티스트로 보아, 주로 pop과 hip-hop 음악을 플레이했음을 알 수 있다. (물론 나를 포함한 이 글을 읽는 사람들은 한국인이기 때문에 잘 모를 것이다... 책에서 그렇다고 하니 일단 믿어 보자.) 이러한 정보를 갖고 있는 사용자에게는 어떤 아이템들을 추천 해 주었는가는 다음 코드를 이용해 확인할 수 있다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">recommendations</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">recommendProducts</span><span class="o">(</span><span class="mi">2093760</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">recommendations</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div>
<p>위 결과는 다음과 같이 상위 5개의 아이템을 추천해 준 결과를 출력한다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Rating(2093760,1300642,0.027983077231064094)
Rating(2093760,2814,0.027609241365462805)
Rating(2093760,1001819,0.027584770801984716)
Rating(2093760,1037970,0.027400202899883735)
Rating(2093760,829,0.027248976510692982)
</code></pre></div>
<p>추천의 수행 결과는 앞서 생성하였던 <code>Rating</code> 객체를 이용하여 표현된다. Rating 객체에는 (사용자 ID, 아티스트 ID, 값) 형태의 데이터가 존재한다. 이름은 Rating 이지만 세번째 필드의 값이 그대로 평점 값을 나타내는 것은 아님을 주의해야한다. ALS 알고리즘에서는 이 값은 0 과 1 사이의 값을 가지며 값이 높을 수록 좋은 추천을 이야기한다.</p>

<p>다음 코드를 이용해 추천된 결과에서 각각의 아티스트 ID 가 어떤 아티스트인지 이름을 확인해 볼 수 있다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">recommendedProductIDs</span> <span class="k">=</span> <span class="n">recommendations</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">product</span><span class="o">).</span><span class="n">toSet</span>

<span class="n">artistById</span><span class="o">.</span><span class="n">filter</span><span class="o">({</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">recommendedProductIDs</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
<span class="o">}).</span><span class="n">values</span><span class="o">.</span><span class="n">collect</span><span class="o">().</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div>
<p>수행 결과는 다음과 같다. 이 결과는 수행시마다 다를 수 있다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">50 Cent
Nas
Kanye West
2Pac
The Game
</code></pre></div>
<p>위 목록의 아티스트는 모두 hip-hop 관련 아티스트이다. 얼핏 보기엔 괜찮아 보이지만 너무 대중적인 가수들이며 사용자의 개인적인 성향을 파악하지는 못한 것 같은 결과를 보인다.</p>

<p><br>
<br></p>

<h2>Next Post</h2>

<p>지금까지는 사용자들의 음악 플레이 기록을 이용하여, 아티스트를 추천해주는 과정을 수행하였다. 다음 포스트에서는 수행한 추천이 얼마나 잘 수행되었는지 평가하는 과정을 진행할 것이다.</p>

<p><br>
<br></p>

<h2>References</h2>

<p>[1] : <a href="http://shop.oreilly.com/product/0636920035091.do">Advanced Analytics with Spark</a></p>

  </div><!-- /.entry-content -->
  
  <center><div><a href="/data%20analysis/2015/07/13/advanced-analytics-with-spark-ch3-1/" class="btn">Read More...</a></div></center>
  
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="/data%20analysis/2015/07/04/advanced-analytics-with-spark-ch2/" title="Spark & 머신 러닝 - Introduction to Spark"><img src="/images/bg1.jpg" alt="Spark & 머신 러닝 - Introduction to Spark"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-07-04T11:09:00-04:00"><a href="/data%20analysis/2015/07/04/advanced-analytics-with-spark-ch2/">July 04, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About Hyunje Jo">Hyunje Jo</a></span></span>
      <!--
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~1 minute
      </span>
      -->
      <!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/data%20analysis/2015/07/04/advanced-analytics-with-spark-ch2/" rel="bookmark" title="Spark & 머신 러닝 - Introduction to Spark" itemprop="url">Spark & 머신 러닝 - Introduction to Spark</a></h1>
    
  </header>
  <div class="entry-content" style="overflow:hidden; height:500px;">
    <p>이 글에서는 Spark가 어떤 형태로 동작하는지 설명하고 간단한 예시를 통해 Spark에 적응하는 과정을 설명한다.</p>

<p>이 포스트는 <a href="http://shop.oreilly.com/product/0636920035091.do">Advanced Analytics with Spark</a>을 정리한 글이다.</p>

<p>이 글에서 다루고자 하는 내용은 Chapter 2이다. Chapter 1은 빅데이터에 대한 개략적인 얘기와, 왜 Spark가 뜨고 있는지, Spark 가 데이터 분석에서 어떠한 역할을 하고 있는지에 대한 설명이 있었다. 그 내용들은 다른 자료들에 많이 있으므로 따로 정리는 하지 않았다.</p>

<p><br>
<br></p>

<h2>Record Linkage</h2>

<p>chapter 2에서는 Record Linkage와 비슷한 작업(ex : <a href="https://en.wikipedia.org/wiki/Extract,_transform,_load">ETL</a>)들을 Spark 로 어떻게 수행하는지에 대해 설명하고, Follow-up 할 수 있도록 하고있다.</p>

<p>실제 데이터를 이용해 분석을 수행할 때 대부분은 수집한 데이터를 그대로 이용하지 않는다. 수집한 데이터를 그대로 이용한다면 잘못된 데이터(값이 비어있거나, 필요없는 데이터가 섞여있거나, 같은 데이터가 중복되어 들어있거나 등등)들이 분석에 그대로 활용되기 때문에 이들을 잘 필터링 해야 한다.</p>

<p>이 책에서 Recoed Linkage는 위의 문제 중 같은 데이터가 다른 형태로 들어있을 때, 그것을 하나의 데이터로 간주하도록 하는 것이라 얘기하고 있다.</p>

<p>이러한 내용들을 수행하기 위해 Record Linkage Comparison Patterns Dataset을 이용한다.</p>

<p><br>
<br></p>

<h2>The Spark Shell and SparkContext</h2>

<p>Spark를 이용하는 방법은 크게 두 가지가 있다. 하나는 Spark Shell 을 통해서 REPL(read-eval-print loop) 형태로 Spark를 이용하는 방법이고, 나머지 방법은 Spark Application 을 IDE를 이용해 작성한 후, 그것을 패키징 하여 Spark Cluster로 Submit하여 수행하는 방법이다.</p>

<p>REPL을 이용하려면 다음과 같은 명령어를 이용해야한다.</p>

<p>(여기서, 개인적인 공부이기 때문에 로컬 클러스터에서 수행함을 가정한다. 또한, Shell은 Scala를 기반으로 작성해야 하기 때문에 Scala 에 대한 이해가 필요하다.)</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>spark-shell --master <span class="nb">local</span><span class="o">[</span>2<span class="o">]</span>
</code></pre></div>
<p>만약 Spark 를 YARN을 이용해 수행시키고 싶다면 다음과 같이 입력한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>spark-shell --master yarn-client
</code></pre></div>
<p><br></p>

<p>이 챕터에서는 <a href="http://bit.ly/1Aoywaq">http://bit.ly/1Aoywaq</a> 링크의 데이터를 이용하고 있다.
이 데이터를 HDFS로 업로드해야 하기 때문에, 다음 과정을 이용해 데이터를 HDFS로 업로드 한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>wget http://bit.ly/1Aoywaq -O donation.zip
<span class="nv">$ </span>unzip donation.zip
<span class="nv">$ </span>unzip <span class="s1">&#39;block_*.zip&#39;</span>
<span class="nv">$ </span>hdfs dfs -mkdir /linkage
<span class="nv">$ </span>hdfs dfs -put block_*.csv /linkage
</code></pre></div>
<p>책에서는 (아직은) Spark-shell을 기준으로 설명하고 있다. 본 글 역시 다른 언급이 있지 않는 이상 Spark-shell 을 기준으로 설명할 것이다.</p>

<p>우선, 다음 명령어를 이용해 데이터가 HDFS에 정상적으로 업로드 되고, 그것을 잘 읽어 오는지 확인한다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">rawblocks</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="s">&quot;/linkage&quot;</span><span class="o">)</span>
<span class="o">...</span>
<span class="n">rawblocks</span><span class="k">:</span> <span class="kt">org.apache.spark.rdd.RDD</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">MapPartitionsRDD</span><span class="o">[</span><span class="err">1</span><span class="o">]</span> <span class="n">at</span> <span class="n">textFile</span> <span class="n">at</span> <span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">21</span>
</code></pre></div>
<p>Spark Shell 에서는 기본적인 SparkContext 객체에 대한 인스턴스를 하나 제공한다. 그 인스턴스에 대한 접근은 <code>sc</code>로 할 수 있으며, <strong>textFile</strong> 함수를 이용해 HDFS에 저장되어 있는 파일을 읽어올 수 있다.</p>

<p>다음 명령어를 이용해 데이터의 상위 10 줄에 어떤 데이터가 들어있는지 확인한다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">head</span> <span class="k">=</span> <span class="n">rawblocks</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">head</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div>
<p>그러면 다음과 같은 값이 들어있음을 알 수 있다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&quot;id_1&quot;,&quot;id_2&quot;,&quot;cmp_fname_c1&quot;,&quot;cmp_fname_c2&quot;,&quot;cmp_lname_c1&quot;,&quot;cmp_lname_c2&quot;,&quot;cmp_sex&quot;,&quot;cmp_bd&quot;,&quot;cmp_bm&quot;,&quot;cmp_by&quot;,&quot;cmp_plz&quot;,&quot;is_match&quot;
37291,53113,0.833333333333333,?,1,?,1,1,1,1,0,TRUE
39086,47614,1,?,1,?,1,1,1,1,1,TRUE
70031,70237,1,?,1,?,1,1,1,1,1,TRUE
84795,97439,1,?,1,?,1,1,1,1,1,TRUE
36950,42116,1,?,1,1,1,1,1,1,1,TRUE
42413,48491,1,?,1,?,1,1,1,1,1,TRUE
25965,64753,1,?,1,?,1,1,1,1,1,TRUE
49451,90407,1,?,1,?,1,1,1,1,0,TRUE
39932,40902,1,?,1,?,1,1,1,1,1,TRUE
</code></pre></div>
<p>이 결과를 보면, csv 데이터의 제일 첫 줄에 각 컬럼이 나타내는 값이 어떤 것인지에 대한 정보가 있다. 이것을 다음과 같은 함수와 명령어를 이용하여 필터링한다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">isHeader</span><span class="o">(</span><span class="n">line</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">line</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">&quot;id_1&quot;</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">noheader</span> <span class="k">=</span> <span class="n">rawblocks</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="n">isHeader</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</code></pre></div>
<p>그 결과로, 다음과 같이 컬럼명이 제외된 데이터 10개를 볼 수 있다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">37291,53113,0.833333333333333,?,1,?,1,1,1,1,0,TRUE
39086,47614,1,?,1,?,1,1,1,1,1,TRUE
70031,70237,1,?,1,?,1,1,1,1,1,TRUE
84795,97439,1,?,1,?,1,1,1,1,1,TRUE
36950,42116,1,?,1,1,1,1,1,1,1,TRUE
42413,48491,1,?,1,?,1,1,1,1,1,TRUE
25965,64753,1,?,1,?,1,1,1,1,1,TRUE
49451,90407,1,?,1,?,1,1,1,1,0,TRUE
39932,40902,1,?,1,?,1,1,1,1,1,TRUE
46626,47940,1,?,1,?,1,1,1,1,1,TRUE
</code></pre></div>
<p><br>
<br></p>

<h2>Structuring Data with Tuples and Case Classes</h2>

<p>지금까지 읽은 데이터를 그대로 읽어서 분석에 활용할 수 있지만, 데이터를 파싱하여 활용하면 더욱 쉽게 활용할 수 있다.</p>

<p>데이터는 다음과 같은 형태를 띄고 있다.</p>

<ul>
<li>처음 2개의 Integer 값 : 레코드에서 매칭되는 환자의 ID</li>
<li>9개의 Double 값 : 9가지의 필드에 대한 매칭 스코어(없을 수 있음)</li>
<li>Boolean 값 : 매치 되는지 여부에 대한 판별결과</li>
</ul>

<p>이를 파싱하기 위해 다음과 같은 <a href="http://docs.scala-lang.org/ko/tutorials/tour/case-classes.html">Case Class</a>를 정의하고 필요한 서브 함수를 작성하여 활용한다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">MatchData</span><span class="o">(</span><span class="n">id1</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">id2</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">scores</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span> <span class="n">matched</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>

<span class="k">def</span> <span class="n">toDouble</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="s">&quot;?&quot;</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span> <span class="k">else</span> <span class="n">s</span><span class="o">.</span><span class="n">toDouble</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">parse</span><span class="o">(</span><span class="n">line</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">pieces</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="sc">&#39;,&#39;</span><span class="o">);</span>
    <span class="k">val</span> <span class="n">id1</span> <span class="k">=</span> <span class="n">pieces</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toInt</span>
    <span class="k">val</span> <span class="n">id2</span> <span class="k">=</span> <span class="n">pieces</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">toInt</span>
    <span class="k">val</span> <span class="n">scores</span> <span class="k">=</span> <span class="n">pieces</span><span class="o">.</span><span class="n">slice</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">11</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">toDouble</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">matched</span> <span class="k">=</span> <span class="n">pieces</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="mi">11</span><span class="o">).</span><span class="n">toBoolean</span>
    <span class="nc">MatchData</span><span class="o">(</span><span class="n">id1</span><span class="o">,</span> <span class="n">id2</span><span class="o">,</span> <span class="n">scores</span><span class="o">,</span> <span class="n">matched</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<p>다음 명령어를 통해 데이터를 파싱하고, 그 결과를 확인한다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">parsed</span> <span class="k">=</span> <span class="n">noheader</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">line</span> <span class="k">=&gt;</span> <span class="n">parse</span><span class="o">(</span><span class="n">line</span><span class="o">))</span>

<span class="n">parsed</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div>
<p>그리고, 지금까지 파싱한 결과를 메모리에 cache()시켜놓는다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">parsed</span><span class="o">.</span><span class="n">cache</span><span class="o">()</span>
</code></pre></div>
<p><br>
<br></p>

<h2>Creating Histograms</h2>

<p><a href="https://en.wikipedia.org/wiki/Histogram">Histogram</a> 은 간단히 말하면, 항목별로 개수를 센 결과를 나타낸다고 할 수 있다. 이 절에서는 지금까지 파싱한 데이터가 <code>matched</code> 필드 값의 종류(true, false)별로 얼마나 존재하는지에 대한 히스토그램을 생성할 것이다. 다행히도 Spark의 RDD에서 기본적으로 제공하는 <strong>countByValue</strong>를 이용하면 쉽게 해결할 수 있다.</p>

<p>다음 명령어를 통해 각 값 별로 얼마만큼의 레코드가 존재하는지 쉽게 카운팅 할 수 있다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">matchCounts</span> <span class="k">=</span> <span class="n">parsed</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">md</span> <span class="k">=&gt;</span> <span class="n">md</span><span class="o">.</span><span class="n">matched</span><span class="o">).</span><span class="n">countByValue</span><span class="o">()</span>
</code></pre></div>
<p>다음과 같은 수행 결과로, 손쉽게 <code>matched</code> 필드의 각 값 별 히스토그램을 생성할 수 있다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">matchCounts</span><span class="k">:</span> <span class="kt">scala.collection.Map</span><span class="o">[</span><span class="kt">Boolean</span>,<span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="kc">true</span> <span class="o">-&gt;</span> <span class="mi">20931</span><span class="o">,</span> <span class="kc">false</span> <span class="o">-&gt;</span> <span class="mi">5728201</span><span class="o">)</span>
</code></pre></div>
<p><br>
<br></p>

<h2>Summary Statistics for Continuous Variables</h2>

<p>앞서 설명된 <strong>countByValue</strong>는 값의 종류에 따라 Histogram 을 생성하는 좋은 방법 중 하나이다. 하지만 Boolean 형태의 값처럼 적은 범위를 갖는 값이 아니라 Continuous Variable, 즉 연속변수와 같은 경우에 사용하기에는 적절하지 않다.</p>

<p>연속변수들에 대해서는 모든 값의 Histogram 을 구하는 것보다 분포에 대한 확률적인 통계 수치(평균, 표준편차, 최대 or 최솟값 등)를 보는 것이 좀 더 간결하게 데이터를 파악할 수 있다.</p>

<p>Spark에서는 이를 위해 <strong>stats</strong>라는 함수를 제공한다. 이 함수를 이용함으로써 손쉽게 특정 변수에 대한 통계적 수치를 출력할 수 있다. 파싱한 값중에 NaN이 들어가 있을 수 있기 때문에, 해당 레코드는 필터링을 수행한 후에 수행시키도록 한다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">java.lang.Double.isNaN</span>
<span class="n">parsed</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">md</span> <span class="k">=&gt;</span> <span class="n">md</span><span class="o">.</span><span class="n">scores</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">filter</span><span class="o">(!</span><span class="n">isNaN</span><span class="o">(</span><span class="k">_</span><span class="o">)).</span><span class="n">stats</span><span class="o">()</span>
</code></pre></div>
<p>위 코드의 수행 결과로 다음과 같은 결과를 볼 수 있다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">org.apache.spark.util.StatCounter = (count: 5748125, mean: 0.712902, stdev: 0.388758, max: 1.000000, min: 0.000000)
</code></pre></div>
<p>또한 Scala의 <strong>Range</strong>를 이용하여 scores 배열에 들어있는 모든 변수에 대한 수치값들에 대한 통계치를 구할 수 있다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">stats</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="mi">9</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="n">parsed</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">md</span> <span class="k">=&gt;</span> <span class="n">md</span><span class="o">.</span><span class="n">scores</span><span class="o">(</span><span class="n">i</span><span class="o">)).</span><span class="n">filter</span><span class="o">(!</span><span class="n">isNaN</span><span class="o">(</span><span class="k">_</span><span class="o">)).</span><span class="n">stats</span><span class="o">()</span>
<span class="o">})</span>
<span class="n">stats</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div>
<p>그 결과는 다음과 같다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(count: 5748125, mean: 0.712902, stdev: 0.388758, max: 1.000000, min: 0.000000)
(count: 103698, mean: 0.900018, stdev: 0.271316, max: 1.000000, min: 0.000000)
(count: 5749132, mean: 0.315628, stdev: 0.334234, max: 1.000000, min: 0.000000)
(count: 2464, mean: 0.318413, stdev: 0.368492, max: 1.000000, min: 0.000000)
(count: 5749132, mean: 0.955001, stdev: 0.207301, max: 1.000000, min: 0.000000)
(count: 5748337, mean: 0.224465, stdev: 0.417230, max: 1.000000, min: 0.000000)
(count: 5748337, mean: 0.488855, stdev: 0.499876, max: 1.000000, min: 0.000000)
(count: 5748337, mean: 0.222749, stdev: 0.416091, max: 1.000000, min: 0.000000)
(count: 5736289, mean: 0.005529, stdev: 0.074149, max: 1.000000, min: 0.000000)
</code></pre></div>
<p><br>
<br></p>

<h2>Creating Reusable Code for Computing Summary Statistics</h2>

<p>하지만, 위와 같은 작업은 매우 비효율적이다. scores 배열에 존재하는 값에 대한 각각의 통계치를 계산하기 위해서 <code>parsed RDD</code>를 매번 다시 계산해야 한다. 물론 앞선 과정에서 <code>parsed RDD</code> 를 <strong>cache</strong> 해 놓긴 하였지만, 데이터가 많아지면 많아질 수록 이 작업의 소요시간은 급속도로 증가할 것이다.</p>

<p>이러한 경우에, 어떠한 <code>RDD[Array[Double]]</code>를 인자로 받아, 값이 정상적으로 들어있는 레코드들에 대한 각 인덱스별 <code>StatCounter</code> 를 갖는 클래스 혹은 함수를 작성하는 것을 생각해 볼 수 있다.</p>

<p>또한, 이러한 작업이 분석 과정에서 반복될 때, 매번 해당 코드를 새롭게 작성하는 것보다 다른 파일에 작성하여 그것을 재사용하는 것이 적절한 방식이다. 때문에 다른 파일에 스칼라 코드를 작성하고, Spark에서 그 파일을 불러와 사용하도록 할 것이다. 다음 소스코드를 다른 파일 <code>StatsWithMissing.scala</code>파일에 저장한 후 사용할 것이며, 멤버변수와 함수에 대해서는 코드의 뒷 부분에서 설명할 것이다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.spark.util.StatCounter</span>

<span class="k">class</span> <span class="nc">NAStatCounter</span> <span class="k">extends</span> <span class="nc">Serializable</span><span class="o">{</span>
    <span class="k">val</span> <span class="n">stats</span><span class="k">:</span> <span class="kt">StatCounter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StatCounter</span><span class="o">()</span>
    <span class="k">var</span> <span class="n">missing</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">NAStatCounter</span> <span class="o">=</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Double</span><span class="o">.</span><span class="n">isNaN</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">missing</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">stats</span><span class="o">.</span><span class="n">merge</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
        <span class="o">}</span>
        <span class="k">this</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">NAStatCounter</span><span class="o">)</span><span class="k">:</span> <span class="kt">NAStatCounter</span> <span class="o">=</span> <span class="o">{</span>
        <span class="n">stats</span><span class="o">.</span><span class="n">merge</span><span class="o">(</span><span class="n">other</span><span class="o">.</span><span class="n">stats</span><span class="o">)</span>
        <span class="n">missing</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">missing</span>
        <span class="k">this</span>
    <span class="o">}</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="o">{</span>
        <span class="s">&quot;stats: &quot;</span> <span class="o">+</span> <span class="n">stats</span><span class="o">.</span><span class="n">toString</span> <span class="o">+</span> <span class="s">&quot; NaN: &quot;</span> <span class="o">+</span> <span class="n">missing</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">NAStatCounter</span> <span class="k">extends</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">NAStatCounter</span><span class="o">().</span><span class="n">add</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<p>앞서 정의한 <code>NAStatCounter</code> 클래스는 두 개의 멤버 변수를 갖고 있다. <code>stats</code>로 정의된 <code>StatCounter</code> 인스턴스는 immutable이고, <code>missing</code>으로 정의된 <code>Long</code> 변수는 mutable 변수이다. 이 클래스를 <code>Serializable</code> 객체를 상속시킨 이유는, Spark 의 RDD에서 이 객체를 사용하기 위해선 반드시 상속을 시켜주어야 한다. 만약 이 상속을 하지 않으면 RDD에서 에러가 발생한다.</p>

<p>클래스의 첫 번째 함수 <code>add</code>는 새로운 Double 형태의 값을 받아 <code>stats</code>변수가 값을 계속 관측할 수 있도록 한다. 만약 인자로 받은 값이 NaN이면, missing 값을 1 증가시키고, NaN이 아니라면 StatCounter 객체에 기록한다. 두 번째 함수 <code>merge</code>는 다른 NAStatCounter 인스턴스를 매개변수로 받아 지금의 인스턴스와 병합시키는 역할을 한다. 세 번째 함수 toString은 쉽게 NAStatCounter 클래스를 출력하기 위해서 오버라이딩 한 것이다. 스칼라에서는 부모 객체의 함수를 오버라이딩 하기 위해선 반드시 함수 앞에 <code>override</code> 키워드를 추가해야 한다.</p>

<p>그리고 class 정의와 함께 NAStatCounter 객체에 대한 <code>companion object</code>를 함께 정의한다. 스칼라에서 object 키워드는 자바에서의 static method 와 같이 어떤 클래스에 대한 helper method를 제공하는 싱글톤 객체를 선언하는데에 이용된다. 이 경우에서처럼 class 이름과 같은 object를 선언하는 것을 <code>companion object</code>를 선언한다고 하며, 여기서의 <code>apply</code> 함수는 <code>NAStatCounter</code> 클래스에 대한 새 인스턴스를 생성하고, 그 인스턴스를 반환하기 전에 Double 값을 더한다.</p>

<p>정상적으로 로드가 되었다면 다음과 같은 메시지가 출력된다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">import org.apache.spark.util.StatCounter
defined class NAStatCounter
defined module NAStatCounter
warning: previously defined class NAStatCounter is not a companion to object NAStatCounter.
Companions must be defined together; you may wish to use :paste mode for this.
</code></pre></div>
<p>경고가 출력되어 문제가 생긴것이 아닌가 할 수 있지만, 무시할 수 있는 경고이다.
다음과 같은 예시로 정상적으로 로드되었는지 확인해 볼 수 있다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">nas1</span> <span class="k">=</span> <span class="nc">NAStatCounter</span><span class="o">(</span><span class="mf">10.0</span><span class="o">)</span>
<span class="n">nas1</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="mf">2.1</span><span class="o">)</span>
<span class="k">val</span> <span class="n">nas2</span> <span class="k">=</span> <span class="nc">NAStatCounter</span><span class="o">(</span><span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span><span class="o">)</span>
<span class="n">nas1</span><span class="o">.</span><span class="n">merge</span><span class="o">(</span><span class="n">nas2</span><span class="o">)</span>
</code></pre></div>
<p>이제 작성한 <code>NAStatCounter</code>클래스를 이용하여 <code>parsed RDD</code>에 들어있는 MatchData 레코드를 처리하자. 각각의 MatchData 인스턴스는 Array[Double] 형태의 매칭 스코어를 포함하고 있다. 배열에 있는 각각의 엔트리마다 <code>NAStatCounter</code> 객체를 생성시켜, 모든 값을 추적하려 한다. 그렇게 하기 위해선 다음과 같은 방식으로 RDD 안에 존재하는 모든 레코드는 Array[Double]을 갖고 있기 때문이 이것을 Array[NAStatCounter]를 갖는 RDD로 변경하면 된다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">nasRDD</span> <span class="k">=</span> <span class="n">parsed</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">md</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="n">md</span><span class="o">.</span><span class="n">scores</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">d</span> <span class="k">=&gt;</span> <span class="nc">NAStatCounter</span><span class="o">(</span><span class="n">d</span><span class="o">))</span>
<span class="o">})</span>
</code></pre></div>
<p>이제, 여러개의 Array[NAStatCounter] 를 하나의 배열로 합치면서 각 인덱스별로 존재하는 NAStatCounter를 병합하면 된다. 이를 위해 다음과 같은 코드를 이용한다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">reduced</span> <span class="k">=</span> <span class="n">nasRDD</span><span class="o">.</span><span class="n">reduce</span><span class="o">((</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="n">n1</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">n2</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">merge</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">}</span>
<span class="o">})</span>
<span class="n">reduced</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div>
<p>그 결과로 다음과 같이 모든 매칭 스코어에 대한 인덱스별 통계 수치를 구할 수 있다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">stats: (count: 5748125, mean: 0.712902, stdev: 0.388758, max: 1.000000, min: 0.000000) NaN: 1007
stats: (count: 103698, mean: 0.900018, stdev: 0.271316, max: 1.000000, min: 0.000000) NaN: 5645434
stats: (count: 5749132, mean: 0.315628, stdev: 0.334234, max: 1.000000, min: 0.000000) NaN: 0
stats: (count: 2464, mean: 0.318413, stdev: 0.368492, max: 1.000000, min: 0.000000) NaN: 5746668
stats: (count: 5749132, mean: 0.955001, stdev: 0.207301, max: 1.000000, min: 0.000000) NaN: 0
stats: (count: 5748337, mean: 0.224465, stdev: 0.417230, max: 1.000000, min: 0.000000) NaN: 795
stats: (count: 5748337, mean: 0.488855, stdev: 0.499876, max: 1.000000, min: 0.000000) NaN: 795
stats: (count: 5748337, mean: 0.222749, stdev: 0.416091, max: 1.000000, min: 0.000000) NaN: 795
stats: (count: 5736289, mean: 0.005529, stdev: 0.074149, max: 1.000000, min: 0.000000) NaN: 12843
</code></pre></div>
<p>또한 다음과 같이 <code>statsWithMissing</code>함수를 정의하고 이를 사용함으로써 좀 더 고급지게(?) 처리할 수 있다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">statsWithMissing</span><span class="o">(</span><span class="n">rdd</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Double</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">NAStatCounter</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">nastats</span> <span class="k">=</span> <span class="n">rdd</span><span class="o">.</span><span class="n">mapPartitions</span><span class="o">((</span><span class="n">iter</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Double</span><span class="o">]])</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">nas</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">NAStatCounter</span><span class="o">]</span> <span class="k">=</span> <span class="n">iter</span><span class="o">.</span><span class="n">next</span><span class="o">().</span><span class="n">map</span><span class="o">(</span><span class="n">d</span> <span class="k">=&gt;</span> <span class="nc">NAStatCounter</span><span class="o">(</span><span class="n">d</span><span class="o">))</span>
        <span class="n">iter</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">arr</span> <span class="k">=&gt;</span> <span class="o">{</span>
            <span class="n">nas</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">arr</span><span class="o">).</span><span class="n">foreach</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">d</span><span class="o">)}</span>
        <span class="o">})</span>
        <span class="nc">Iterator</span><span class="o">(</span><span class="n">nas</span><span class="o">)</span>
    <span class="o">})</span>
    <span class="n">nastats</span><span class="o">.</span><span class="n">reduce</span><span class="o">((</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="n">n1</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">n2</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">merge</span><span class="o">(</span><span class="n">b</span><span class="o">)}</span>
    <span class="o">})</span>
<span class="o">}</span>
</code></pre></div>
<p><br>
<br></p>

<h2>Simple Variable Selection and Scoring</h2>

<p>앞서 작성한 <code>statsWithMissing</code> 함수를 이용해 다음과 같이 parsedRDD 로부터 각 데이터가 매치되는지 여부에 따라 scores의 분포가 어떻게 되는지 구할 수 있다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">statsm</span> <span class="k">=</span> <span class="n">statsWithMissing</span><span class="o">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">matched</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">scores</span><span class="o">))</span>
<span class="k">val</span> <span class="n">statsn</span> <span class="k">=</span> <span class="n">statsWithMissing</span><span class="o">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">filter</span><span class="o">(!</span><span class="k">_</span><span class="o">.</span><span class="n">matched</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">scores</span><span class="o">))</span>
</code></pre></div>
<p>두 변수 <code>statsm</code>과 <code>statsn</code>은 전체 데이터를 매치되는지 여부에 따라 두 개의 서브셋으로 나누어 scores의 확률적 분포에 대한 정보를 갖고 있다. 여기서 두 개의 각 서브셋에 존재하는 scores 배열의 각 칼럼 별 정보를 비교함으로써, 두 서브셋 차이에 각 feature 별로 어떤 차이를 갖고 있는지를 비교할 수 있다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">statsm</span><span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">statsn</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="n">missing</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">missing</span><span class="o">,</span> <span class="n">m</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">mean</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">mean</span><span class="o">)</span>
<span class="o">}.</span><span class="n">zipWithIndex</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div>
<p>위 코드의 수행 결과로 다음과 같은 결과가 나온다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">((1007,0.285452905746686),0)
((5645434,0.09104268062279874),1)
((0,0.6838772482597568),2)
((5746668,0.8064147192926266),3)
((0,0.03240818525033473),4)
((795,0.7754423117834044),5)
((795,0.5109496938298719),6)
((795,0.7762059675300523),7)
((12843,0.9563812499852178),8)
</code></pre></div>
<p>좋은 feature 는 두 가지의 속성이 있다. 하나는 그 feature에 따른 크기가 큰 차이가 존재하는 것이고, 모든 데이터 쌍(두 서브셋 사이의)에 대해서도 균일하게 발생한다는 것이다. 이러한 이론에 따라 인덱스 1의 feature 는 좋은 feature라고 할 수 없다. 값이 존재하지 않아 missing이 카운트 된 횟수가 매우 많으며, 두 서브셋의 평균값의 차이가 0.09로 매우 적다(값의 범위가 0 에서 1인 것임을 감안했을 때). Feature 4 또한 적절치 않다. Feature 4는 모든 값이 존재하지만 평균 값의 차이가 0.03이므로 두 데이터 그룹 사이에 별 차이가 없기 때문이다.</p>

<p>반면, feature 5와 7은 훌륭한 feature 이다. 대부분의 데이터에 대해 값이 존재하며, 두 그룹의 평균 차이가 매우 크기 때문이다. 그리고 feature 2, 6, 8 역시 괜찮은 feature 라 할 수 있다. Feature 0과 3은 좀 애매하다고 할 수 있다. Feature 0은 대부분의 데이터에서 관측 가능하지만 두 셋의 평균 차이가 크지 않고, 반대로 Feature 3은 두 셋의 평균 차이가 크지만 많은 데이터에서 관측하기가 어렵다. 이 정보들은 두 데이터 셋을 명확하게 표현하기가 어렵다.</p>

<p>앞서 설명한 내용을 바탕으로하여 쓸만한 feature(2, 5, 6, 7, 8)를 이용해 각 데이터에 대한 scoring model을 만들 것이다. 이 모델에서는 NaN 값은 0으로 처리하여 계산할 것이다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">naz</span><span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">d</span><span class="o">))</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="n">d</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Scored</span><span class="o">(</span><span class="n">md</span><span class="k">:</span> <span class="kt">MatchData</span><span class="o">,</span> <span class="n">score</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>
<span class="k">val</span> <span class="n">ct</span> <span class="k">=</span> <span class="n">parsed</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">md</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">score</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">naz</span><span class="o">(</span><span class="n">md</span><span class="o">.</span><span class="n">scores</span><span class="o">(</span><span class="n">i</span><span class="o">))).</span><span class="n">sum</span>
    <span class="nc">Scored</span><span class="o">(</span><span class="n">md</span><span class="o">,</span> <span class="n">score</span><span class="o">)</span>
<span class="o">})</span>
<span class="n">ct</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">md</span><span class="o">.</span><span class="n">matched</span><span class="o">).</span><span class="n">countByValue</span><span class="o">()</span>

<span class="o">...</span>

<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">Boolean</span>,<span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="kc">true</span> <span class="o">-&gt;</span> <span class="mi">20931</span><span class="o">,</span> <span class="kc">false</span> <span class="o">-&gt;</span> <span class="mi">5728201</span><span class="o">)</span>
</code></pre></div>
<p>생성한 <code>ct RDD</code> 에 여러 Threshold 값들을 지정하고, 매치되었는지 여부에 따라 카운팅을 함으로써 데이터의 속성에 대해 파악할 수 있다.</p>

<p>다음 결과는 Threshold 를 4.0 으로 정하였는데, 이것은 각각의 feature 에 대해 평균적으로 0.8 이상을 갖고 있음을 의미한다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">ct</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">score</span> <span class="o">&gt;=</span> <span class="mf">4.0</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">md</span><span class="o">.</span><span class="n">matched</span><span class="o">).</span><span class="n">countByValue</span><span class="o">()</span>

<span class="o">...</span>

<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">Boolean</span>,<span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="kc">true</span> <span class="o">-&gt;</span> <span class="mi">20871</span><span class="o">,</span> <span class="kc">false</span> <span class="o">-&gt;</span> <span class="mi">637</span><span class="o">)</span>
</code></pre></div>
<p>위와 같은 결과는 matched에 속하는 데이터 중 true를 갖는 데이터들의 99%이상이 feature(2, 5, 6, 7, 8) 합이 4 이상임을 나타내고, false를 갖는 데이터는 대부분(98.8%)이 4.0 이하의 값을 갖는다는것을 얘기한다.</p>

<p>다음과 같이 score 값을 2.0 으로 필터링 하면 다음과 같은 결과를 얻을 수 있다.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">ct</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">score</span> <span class="o">&gt;=</span> <span class="mf">2.0</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">md</span><span class="o">.</span><span class="n">matched</span><span class="o">).</span><span class="n">countByValue</span><span class="o">()</span>

<span class="o">...</span>

<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">Boolean</span>,<span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="kc">true</span> <span class="o">-&gt;</span> <span class="mi">20931</span><span class="o">,</span> <span class="kc">false</span> <span class="o">-&gt;</span> <span class="mi">596414</span><span class="o">)</span>
</code></pre></div>
<p>이 결과는 matched 값이 true 인 경우에는 모든 데이터에가 feature 의 합이 2.0 이상이라는 것과, matched 값이 false인 경우에는 여전이 90% 이상이 feature 합이 2.0 미만이라는 것을 알 수 있다.</p>

<p>앞의 예시에서는 매우 간단한 특정 feature들의 합으로 matched 값에 따라 분류된 두 데이터 셋의 특성에 대해 알아봤지만, 이를 다양하게 변화시킴으로써 주어진 데이터셋에 대해 또 다른 새로운 정보들을 얻을 수 있을 것이다.</p>

<p>지금까지 Spark를 사용해보고, 이를 이용해 간단한 데이터셋을 필터링하고, 데이터셋의 특성에 대해 파악해보았다. 다음 장부터는 또 다른 데이터 셋을 이용해 좀 더 깊이있는 분석을 해 볼 것이다.</p>

  </div><!-- /.entry-content -->
  
  <center><div><a href="/data%20analysis/2015/07/04/advanced-analytics-with-spark-ch2/" class="btn">Read More...</a></div></center>
  
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="">1</a></li>
    

    
    

    
    
    

    
      
        <li><strong class="current-page">2</strong></li>
      
    
      
        
        
        
          
          
        
        <li><a href="/page3/">3</a></li>
      
    
      
        
        
        
          
          
        
        <li><a href="/page4/">4</a></li>
      
    

    
    

    
      <li><a href="/page5/">5</a></li>
    

    
    
      <li><a href="/page3/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2015 Hyunje Jo.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/assets/js/scripts.min.js"></script>

<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-62281776-2', 'auto');
  ga('send', 'pageview');

</script>


<!-- Mathjax -->
<script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


          

</body>
</html>